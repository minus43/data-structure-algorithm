<FDSC>
FDSC는 Fundamentals of Data Structures in C의 줄임, 너무 길어서..
1. 기본 개념 
  1.1. 개요: 시스템 생명 주기
    대형 컴퓨터 프로그램들을 바라보는 프로그래머
      -> 매우 복잡하게 상호 작용하는 부품으로 구성된 시스템과 비슷하다.
        ->시스템과 비슷하게 이런 프로그램들은 '시스템 생명 주기' 라는 개발 단계를 거친다.
    시스템 생명 주기(System life cycle)
      1. 요구사항(requirement)
        프로그램의 목적과 입력과 결과를 기술한다.
      2. 분석(analysis)
        문제들을 실제로 다룰 수 있는 범위로 나눈다.
        상향식(bottom-up) 접근과 하향식(top-down) 접근
          상향식 접근
            말 그대로 가장 완성된 단계에서 접근하려는 것, 코딩에 중점을 둠
            목적과 일치하지 않는 경우가 생길 수 있다.
          하향식 접근
            최종 결과가 될 프로그램을 다룰 수 있는 부분으로 쪼개어 설계하고 구현
      3. 설계(design)
        프로그램이 필요로 하는 자료 객체들과 연산들을 결정한다. 
        이때 실제 구현에 필요한 세부적인 사항은 무시한다.(효과적인 구현을 위해서 다양한 언어들에 대해서 고려할 수 있어야 한다.)
      4. 정제(refinement)와 코딩(coding)
        설계 단계에서 결정한 자료 객체의 표현을 결정하고 연산들을 구현한다.
        자료 객체의 표현 방법이 연산의 효율성을 결정할 수 있다.
      5. 검증(verification)
        정확성 증명(correctness proof)
          수학적 기법으로 증명이 가능할 수 있다. 
          그러나, 시간적이나 질적으로 손해일 수 있다.
          이미 증명된 알고리즘을 이용하는 것도 방법이다.
        테스트(testing)
          코딩 단계나 그 이전에서 테스트를 프로그램의 증명을 해낼 수 있다.
          그러나, 테스트는 테스트 데이터와 수행 가능한 코드를 필요로 한다.
          테스트 데이터는 모든 프로그램 단위들이 정확히 수행되는지를 검증할 수 있어야 한다.
          실행 시간도 중요하다.
        오류 제거(error removal)
          정확성 증명과 테스트에서 발생한 오류가 발생한 코드를 수정
          수정에 용이하고 오류에 잘 대처할 수 있도록 코드에 대한 설명을 적어놓는 것이 좋다.

  1.2 포인터와 동적 할당
    포인터(pointer)
      메모리의 주소값을 저장하는 변수
      &-> 주소 연산자, 주소를 가져옴
      *-> 역참조(derefernce), 이 포인터가 가리키는 변수를 참조
      NULL-> 어떤 객체도 가리키지 않는 널 포인터(null pointer)를 표시하는 매크로, 0으로 표현되기도 함(정수인 변수를 초기화할 때 쓰는 것과 비슷하게 생각)
    동적 메모리 할당
      프로그램 실행 전에 사용할 메모리의 크기를 표시할 수 있지만, 그렇지 않은 경우 존재.
      실행 중에 메모리를 할당할 수 있게 하는 히프(heap) 기법
        *메모리의 구조(낮은 구조순)*
          1. 코드(code) 영역
            실행할 프로그램의 코드
          1. 데이터(data) 영역
            전역 변수와 정적 변수, 프로그램 시작과 함께 할당되고 프로그램 종료시 소멸
          3. 힙(heap) 영역
            사용자의 동적 할당, 프로그램 실행 중에 할당, 낮은 주소에서 높은 주소순으로 할당
          4. 스택(stack) 영역
            함수의 호출과 관련된 지역 변수와 매개 변수, 함수 호출시 할당, 함수 호출 완료시 소멸, 높은 주소에서 낮은 주소순으로 할당
        malloc()
          #include<stdilb.h>
          void* malloc(size_t size);
            반환형태: void 형 포인터, 사용자가 할당받고자 하는 메모리가 어떤 자료형인지는 형변환으로 해줘야 한다. 
            인수: 사용자 정의 자료형으로 할당받고자 하는 메모리의 크기(byte)
            *인수&인자*
              인수(argument)
                함수를 호출할 때 건네주는 변수
              인자(parameter)
                함수에서 정의 되어 사용되는 변수
          전달된 인자에 맞는 메모리 블록을 찾고, 블록의 첫번째 주소를 반환한다.
        free()
          #include<stdilb.h>
          void free(void *ptr);
            반환형태: void형, 반환값 없음
            인수: 해제하고자 하는 메모리 공간을 가리키는 포인터
          사용이 끝난 메모리를 해제하지 않으면 메모리가 부족해지는 메모리 누수(memory leak) 현상 발생 가능
        calloc()
          #include<stdilb.h>
          void* calloc(size_t nmemb, size_t size);
            반환형태: void 형 포인터, malloc과 동일
            인수1: 할당받고자 하는 메모리 블록의 개수
            인수2: 각 블록의 바이트 개수
          malloc과의 차이점
            두 개의 인수를 가짐
            메모리를 할당 받으면 헤당 메모리의 비트값 0으로 초기화
          calloc도 사용하고 free로 메모리 해제해야 됨
        realloc()
          #include <stdlib.h>
          void* realloc(void *ptr, size_t size);
            반환형태: void형 포인터
            인수1: 크기를 바꾸고자 하는 메모리 공간을 가리키는 포인터
            인수2: 재할당할 메모리의 크기(byte)
          이미 할당된 메모리의 크기를 바꾸어 재할당할 때 씀
          만약 첫 인수에 NULL이 전달된다?
            -> 바꾸고자 하는 메모리 공간이 없다 -> malloc과 동일한 동작을 함
            



            

